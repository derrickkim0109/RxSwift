/* 
  Localizable.strings
  RxMarbles

  Created by Pavel Grechikhin on 24/02/2019.
  Copyright © 2019 AnjLab. All rights reserved.
*/

"operators" = "Операторы";

"edit_learn_experiment" = "Редактируй. Изучай. Эксперементируй.";

"add_new_change_colors_and_values_in" = "Добавляй новое,\nменяй цвета и значения в ";
"edit_mode" = "режим редактирования";
"move_events_around" = "перемещай события";
"help_button_title" = "Помощь";
"operators_to" = " RX операторов для ";
"explore" = "исследования";

"share_your_diagrams" = "Делись своими схемами";

"spread_the_world" = "Делись информацией";

//amb
"amb" = "Из всех Observable в результирующий попадают только элементы того, что первый начинает их генерировать, остальные игнорируются.";

//buffer
"buffer" = "Периодически собирает элементы Observable в стеки и отдает их (не отдает элементы Observable по одному).";

//catch error
"catchError" = "Позволяет перехватить ошибку сгенерированную Observable и заменить ее на новый Observable.";
"catchErrorJustReturn" = "Позволяет перехватить ошибку сгенерированную Observable и заменить ее на новый Observable.";

//with latest from
"withLatestFrom" = "Как только первый Observable генерирует элемент, проверяется, сгенерирован ли хоть один элемент во втором Observable, и если да, то берутся последние элементы из первого Observable и второго Observable и используются в качестве аргументов для переданной функции, результат которой генерируется результирующий Observable в качестве элемента.";

//combine latest
"combineLatest" = "Когда элемент испускается одним из двух Observable, объединяет последний элемент, испускаемый каждым Observable с помощью указанной функции и испускает элемент на основе результатов этой функции.";

//concat
"concat" = "Испускает event'ы от двух или более Observable без их чередования";

//throttle
"throttle" = "Испускает первый и последний элемент Observable в течение последовательного промежутка времени.";

//debounce
"debounce" = "Испускает элементы Observable если только прошел заданный промежуток времени с последнего emit'а.";

//delaySubscription
"delaySubscription" = "Устанавливает задержку на emit элементов у Observable.";

//distinctUntilChanged
"distinctUntilChanged" = "Убирает повторяемые элементы, которые emit'ит Observable.";

//elementAt
"elementAt" = "Emit'ить только элемент n.";

//empty
"empty" = "Создает Observable, который не emit'ит элементы.";

//filter
"filter" = "Emit'ит только те элементы Observable, что проходят тест предиката.";

//flatMap
"flatMap" = "Преобразует элементы всех Observable и объединяет в один Observable.";

//flatMapFirst
"flatMapFirst" = "Преобразует элементы всех Observable и объединяет в один Observable.";

//flatMapLatest
"flatMapLatest" = "Преобразует элементы всех Observable и объединяет в один Observable.";

//ignoreElements
"ignoreElements" = "Не emit'ить какие-либо элементы из Observable, но отображать его уведомление о прекращении.";

//interval
"interval" = "Создает бесконечную последовательность, возрастающую с 0 с шагом 1 с указанной периодичностью.";

//just
"just" = "Cоздает Observable, который генерирует только один элемент.";

//map
"map" = "Преобразует элементы Observable применяя к ним заданную функцию.";
"mapWithIndex" = "Преобразует элементы Observable применяя к ним заданную функцию, отличие от map в том, что в функцию передается еще один элемент, а именно индекс сгенерированного элемента.";

"merge" = "Объединяет несколько Observable в один, элементы идут в том порядке, в котором были отправлены.";

"never" = "Пустая последовательность, чьи observer'ы никогда не вызовутся, то есть не будет сгенерировано ни одно событие.";

"of" = "Последовательность из переменного количества элементов. После всех элементов генерируется Completed.";

"reduce" = "Применяет функцию к каждому элементу, после чего отправляет конечное значение.";

"repeatElement" = "Бесконечно создает указанный элемент, без задержек. Никогда не будут сгенерированы события Completed или Error.";

"retry" = "Позволяет перехватить сгенерированную ошибку из Obseervable и в зависимости от переданного параметра попытаться запустить Observable c начала нужное число раз в надежде, что ошибка не повторится.";

"sample" = "Emit'ит самые последние элементы, Observable в течение временных интервалов.";

"scan" = "Apply a function to each item emitted by an Observable, sequentially, and emit each successive value.";

"single" = "Из исходной последовательности берется единственный элемент, если элементов больше 1, то генерируется ошибка.";

"skipDuration" = "Пропустить первые n элементов Observable.";
"skip" = "Пропустить первые n элементов Observable.";

"skipUntil" = "Пропусткает элементы Observable до тех пор пока второй Observable не начнет посылать элементы.";

"skipWhile" = "Отбрасывать элементы Observable, пока указанное условие не станет ложным.";
"skipWhileWithIndex" = "Отбрасывать элементы Observable, пока указанное условие не станет ложным, отличие от skipWhile в том, что еще одним передаваем аргументов в функцию является индекс сгенерированного элемента.";

"startWith" = "В начало Observable добавляются элементы, переданные в качестве аргумента.";

"switchLatest" = "При нескольких Observable, дублирует элементы первого, когда второй начинает отправку элементов, то отбрасывает элементы первого и производит отписку, таким образов в финальный Observable получаем только элементы последнего Observable.";

"take" = "Emit'ит только первые n элементов Observable.";
"takeDuration" = "Emit'ит только первые n элементов Observable.";
"takeLast" = "Emit'ит только конечные n элементов Observable.";

"takeUntil" = "Отбрасывать любые элементы, посылаемые Observable после того, как второй Observable посылает элемент или завершается.";

"takeWhile" = "Дублирует элементы  Observable, пока условие не станет ложным.";
"takeWhileWithIndex" = "Дублирует элементы  Observable, пока условие не станет ложным.";

"throw" = "Создайте Observable, который не выдает элементов и завершается с ошибкой.";

"timeout" = "Дублирует элементы из Observable, но если в течение указанного времени Observable не сгенерировал ни одного элемента, генерирует ошибку.";

"timer" = "Создание Observable, который выдает определенный элемент после заданной задержки.";

"toArray" = "Преобразование Observable объекта в другой объект или структуру данных.";

"zip" = "Объедините элементы нескольких Observable с помощью определенной функции и выделите отдельные элементы для каждой комбинации на основе результатов этой функции.";

"read" = "Читать";
"more" = "подробнее";
